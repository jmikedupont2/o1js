# Idea

see idea.yaml

The idea is to introspect o1js, by observing, orienting, deciding and acting on the internal state and
the external state. We can take the multi headed value network and the policy network of deepmind as inspiration,
from what I understand we can imagine a hydra like system of a hive mind
with many actors or agents in a blockchain network. 
Each agent can have multiple accounts, we can model them with mina accounts and keys.
We can store the keys in private variables attached to build jobs on private build servers.
The agents then run in the build job and use the wallet via the key.
The build job is passed in others variable like the current branch or commit, this is basically your github action job context, or gitlab or other build system.

The state of the git tree is part of the hash of the commit. 
We can include those hashses in the proof, so we can recursivly hash the repos and subrepos and packages used.

We extract knowledge from the runtime and construct zksnarks about them using o1js itself.

So we can say each account can be linked with a project, and o1js is one such project but it is a foundational
part that creates a whole ecosystem.

So we can think of it as a prelude or setting the stage for the work to be done.

Thus we can create a single hash of the entire o1js system knowledge, including its state, inputs, outputs, environmental bindings, processes, servers, clusters, networks, accounts, deployments, in a reflective vernacular
system that unites the models of different domains.

By using rdf owl ontologies derived from vernacular ast dumps of compiler graphs
we can label and reference versions of this vernacular data type system of unreflected linguistic
data. The paths of unimath unite the model with prolog unification to construct a platonic idea
of unity which we can reference with the uu or universe of universes,  in unimath, or the by the symbol of 1, in our imagination. So we can lift all the data types as facets of the universe, each declaration in context
of a stream of output, this stream can self reflect over itself creating a closure of introspective thought,
we can address the moment this way creating self and other references at difference scales and measures.

So we now understand the universe of types, we can think of instances of those types as prototypes,
and we can create content addressable sparse representations of these graphs. We can think of this as the tree of knowledge. This can be seen as the initial accounts or prelude as well in a metaphor. So by thinking about mina accounts we can think about type systems used, and we have a mina account for the mina account as the base template.
each user can publish smart contracts that define new types. We can create a canonical vernacular embedding that
allows a kind of "latin" to speak about other languages in the project.

The point of this is to paint a picture of the idea. to give a story or context to the project.
With rdf now we can construct statements about subjects from any part of the system, even other statements, which can be expressed as objects with no identifier, a blank object constructed out of data, like an empty list being filed with a pair, or a pair of pairs, or a linked list, different types of data can be constructed.

Lets summarize:

create a graphql server for the following,
include interfaces for sparql etc.
